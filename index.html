<html>
<head>
  <style>
    body {
      background-color: lightcoral;
      overflow-x: hidden;
      overflow-y: hidden;
      color: darkslategrey;
      margin: 0;
      text-align: center;
    }
    .content {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      min-height:100vh;
    }
    .bigBubble {
      background-color: lightpink;
      position:absolute;
      top:-100vh;
      left:-50vh;
      width: 200vh;
      height: 200vh;
      border-radius:100vh;
      z-index: -5;
    }
    .mediumBubble {
      background-color: lightgrey;
      position:absolute;
      top:-100vh;
      left:-18.75vh;
      width: 150vh;
      height: 150vh;
      border-radius:75vh;
      z-index: -4;
    }
    .smallBubble {
      background-color: lightblue;
      position:absolute;
      top:-50vh;
      left:20vh;
      width: 60vh;
      height: 60vh;
      border-radius:30vh;
      z-index: -3;
    }
    .slowBubble {
      animation-name:bubbling;
      animation-duration: 20s;
      animation-iteration-count: infinite;
    }
    .fastBubble {
      animation-name:bubbling;
      animation-duration: 10s;
      animation-iteration-count: infinite;
    }
    @keyframes bubbling {
      from {
        transform: scale(1);
        animation-timing-function: ease-out;
      }
      50% {
        transform: scale(1.10);
        animation-timing-function: ease-in;
      }
      to {
        transform: scale(1);
      }
    }
    h1 {
      font-size: 30vw;
      font-size: min(90vw, 90vh);
      margin: 0;
    }
    h2 {
      font-size: 10vw;
      font-size: min(10vw,10vh);
      margin: 0;
      text-transform: uppercase;
    }
    h3 {
      font-size: 5vw;
      font-size: min(5vw,5vh);
      margin: 0;
    }
    .hide {
      transition:all 1s;
      filter: blur(5px);
      opacity: 0;
    }
    .emerge {
      transition:all 1s;
      filter: blur(0px);
      opacity: 1;
    }
    button {
      border-radius:1vw;
      padding:1vw;
      background: rgba(255,255,255,0.5);
      color: darkslategrey;
    }
  </style>
</head>
<body>
  <div class="bigBubble slowBubble"></div>
  <div class="mediumBubble slowBubble"></div>
  <div class="smallBubble slowBubble"></div>
  <div class="content">
    <h3>Turn up your volume.</h3>
    <h2>Can you hear anything?</h2>
    <div><button><h2>Yes</h2></button></div>
  </div>
  <script>
    const audioCtx = new AudioContext();
    async function load() {     
      const response = await fetch('sample.mp3');
      const arrayBuffer = await response.arrayBuffer();
      const originAudioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      const trackSource = audioCtx.createBufferSource();
      trackSource.buffer = originAudioBuffer;
      trackSource.connect(audioCtx.destination);
      return trackSource;
    }

    class VolumeAnalyser {
      
      samplesTotal = 0;
      numberOfSamples = 0;

      constructor(sourceNode) {
        this.anal = audioCtx.createAnalyser();
        this.anal.maxDecibels = VolumeAnalyser.maxDecibels;
        this.anal.minDecibels = VolumeAnalyser.minDecibels;
        this.anal.smoothingTimeConstant = 0.9;
        this.anal.fftSize = 32;
        
        const processor = audioCtx.createScriptProcessor(1024, 1, 1);

        sourceNode.connect(this.anal);
        this.anal.connect(processor);
        
        this.amplitudeArray = new Uint8Array(this.anal.frequencyBinCount);
        processor.onaudioprocess = this.process.bind(this);
      }

      process() {
        this.anal.getByteFrequencyData(this.amplitudeArray);
        let sampleTotal = (this.amplitudeArray[0]+this.amplitudeArray[1])/2;
        if(sampleTotal > 0) {
          this.samplesTotal += sampleTotal;
          this.numberOfSamples++;
        }
      }

      getAverageVolume() {
        return this.samplesTotal/this.numberOfSamples/255*VolumeAnalyser.getRange();
      }

      disconnect() {
        this.anal.disconnect();
      }

      static getRange() {
        return this.maxDecibels - this.minDecibels;
      }
    }
    VolumeAnalyser.maxDecibels = -30;
    VolumeAnalyser.minDecibels = -50;

    async function handleMicrophoneSuccess(stream) {
      let trackSource = await load();
      trackSource.addEventListener('ended', () => {
        mediaRecorder.stop();
      });
      const trackAnal = new VolumeAnalyser(trackSource);

      const streamSource = audioCtx.createMediaStreamSource(stream);
      const anal = new VolumeAnalyser(streamSource);

      const options = {mimeType: 'audio/webm'};
      const recordedChunks = [];
      const mediaRecorder = new MediaRecorder(stream, options);

      mediaRecorder.addEventListener('dataavailable', async function(e) { //assuming this event only happens after recording 
        trackSource.disconnect();
        trackAnal.disconnect();
        streamSource.disconnect();
        anal.disconnect();
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
        }
        const recordedChunksBlob = new Blob(recordedChunks);
        const offlineAudioCtx = new OfflineAudioContext(1, trackSource.buffer.duration*48000, 48000);
        const originTrackSource = offlineAudioCtx.createBufferSource();
        originTrackSource.buffer = trackSource.buffer;
        originTrackSource.connect(offlineAudioCtx.destination);

        const recordedArrayBuffer = await recordedChunksBlob.arrayBuffer();
        const recordedAudioBuffer = await audioCtx.decodeAudioData(recordedArrayBuffer);
        const recordedTrackSource = offlineAudioCtx.createBufferSource();
        recordedTrackSource.buffer = recordedAudioBuffer;
        const gain = offlineAudioCtx.createGain();
        gain.gain.value = trackAnal.getAverageVolume() - anal.getAverageVolume();
        recordedTrackSource.connect(gain);
        gain.connect(offlineAudioCtx.destination);

        originTrackSource.start();
        recordedTrackSource.start();
        const render = await offlineAudioCtx.startRendering();
        const mixRawData = render.getChannelData(0);
        const mixDataBlob = new Blob(mixRawData);
        var mix = audioCtx.createBufferSource();
        mix.buffer = render;
        mix.connect(audioCtx.destination);
        mix.start();
      });

      mediaRecorder.start();
      trackSource.start();

    };

    navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleMicrophoneSuccess);
  </script>
</body>
</html>