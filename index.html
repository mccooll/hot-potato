<html>
<head>
  <style>
    body {
      background-color: lightcoral;
      overflow-x: hidden;
      overflow-y: hidden;
      color: darkslategrey;
      margin: 0;
      text-align: center;
    }
    .content {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      min-height:100vh;
    }
    .bigBubble {
      background-color: lightpink;
      position:absolute;
      top:-100vh;
      left:-50vh;
      width: 200vh;
      height: 200vh;
      border-radius:100vh;
      z-index: -5;
    }
    .mediumBubble {
      background-color: lightgrey;
      position:absolute;
      top:-100vh;
      left:-18.75vh;
      width: 150vh;
      height: 150vh;
      border-radius:75vh;
      z-index: -4;
    }
    .smallBubble {
      background-color: lightblue;
      position:absolute;
      top:-50vh;
      left:20vh;
      width: 60vh;
      height: 60vh;
      border-radius:30vh;
      z-index: -3;
    }
    .slowBubble {
      animation-name:bubbling;
      animation-duration: 20s;
      animation-iteration-count: infinite;
    }
    .fastBubble {
      animation-name:bubbling;
      animation-duration: 10s;
      animation-iteration-count: infinite;
    }
    @keyframes bubbling {
      from {
        transform: scale(1);
        animation-timing-function: ease-out;
      }
      50% {
        transform: scale(1.10);
        animation-timing-function: ease-in;
      }
      to {
        transform: scale(1);
      }
    }
    h1 {
      font-size: 30vw;
      font-size: min(90vw, 90vh);
      margin: 0;
    }
    h2 {
      font-size: 10vw;
      font-size: min(10vw,10vh);
      margin: 0;
      text-transform: uppercase;
    }
    h3 {
      font-size: 5vw;
      font-size: min(5vw,5vh);
      margin: 0;
    }
    .hide {
      transition:all 1s;
      filter: blur(5px);
      opacity: 0;
    }
    .emerge {
      transition:all 1s;
      filter: blur(0px);
      opacity: 1;
    }
    button {
      border-radius:1vw;
      padding:1vw;
      background: rgba(255,255,255,0.5);
      color: darkslategrey;
    }
  </style>
</head>
<body>
  <div class="bigBubble slowBubble"></div>
  <div class="mediumBubble slowBubble"></div>
  <div class="smallBubble slowBubble"></div>
  <div class="content">
    <h3>Turn up your volume.</h3>
    <h2>Can you hear anything?</h2>
    <div><button><h2>Yes</h2></button></div>
  </div>
  <script>
    const audioCtx = new AudioContext();
    var originAudioBuffer;
    let duration = 0; //messy
    const maxDecibels = -30;
    const minDecibels = -50;
    async function load() {     
      const response = await fetch('sample.mp3');
      const arrayBuffer = await response.arrayBuffer();
      originAudioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      duration = originAudioBuffer.duration; //messy
      const trackSource = audioCtx.createBufferSource();
      trackSource.buffer = originAudioBuffer;
      trackSource.connect(audioCtx.destination);
      return trackSource;
    }
    async function handleMicrophoneSuccess(stream) {
      let trackSource = await load();
      trackSource.addEventListener('ended', () => {
        mediaRecorder.stop();
      });
      const trackAnal = audioCtx.createAnalyser();
      trackAnal.maxDecibels = maxDecibels;
      trackAnal.minDecibels = minDecibels;
      trackAnal.smoothingTimeConstant = 0.9;
      trackAnal.fftSize = 32;
      const trackProcessor = audioCtx.createScriptProcessor(1024, 1, 1);
      let trackAmplitudeArray = new Uint8Array(trackAnal.frequencyBinCount);
      trackSource.connect(trackAnal);
      trackAnal.connect(trackProcessor);
      let trackAvg = 0;
      let trackTotalOfSamples = 0;
      let trackSamples = 0;
      trackProcessor.onaudioprocess = function() {
        trackAnal.getByteFrequencyData(trackAmplitudeArray);
        let sampleTotal = (trackAmplitudeArray[0]+trackAmplitudeArray[1])/2;
        if(sampleTotal > 0) {
          trackTotalOfSamples += sampleTotal;
          trackSamples++;
          trackAvg = trackTotalOfSamples/trackSamples;
        }
      }

      const streamSource = audioCtx.createMediaStreamSource(stream);
      const anal = audioCtx.createAnalyser();
      anal.maxDecibels = maxDecibels;
      anal.minDecibels = minDecibels;
      anal.smoothingTimeConstant = 0.9;
      anal.fftSize = 32;
      const processor = audioCtx.createScriptProcessor(1024, 1, 1);
      let amplitudeArray = new Uint8Array(anal.frequencyBinCount);
      streamSource.connect(anal);
      anal.connect(processor);
      let avg = 0;
      let totalOfSamples = 0;
      let samples = 0;
      processor.onaudioprocess = function() {
        console.log('processing');
        anal.getByteFrequencyData(amplitudeArray);
        let sampleTotal = (amplitudeArray[0]+amplitudeArray[1])/2;
        if(sampleTotal > 0) {
          totalOfSamples += sampleTotal;
          samples++;
          avg = totalOfSamples/samples;
        }
      }

      const options = {mimeType: 'audio/webm'};
      const recordedChunks = [];
      const mediaRecorder = new MediaRecorder(stream, options);

      mediaRecorder.addEventListener('dataavailable', async function(e) { //assuming this event only happens after recording 
        trackSource.disconnect();
        trackAnal.disconnect();
        streamSource.disconnect();
        anal.disconnect();
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
        }
        const recordedChunksBlob = new Blob(recordedChunks);
        const offlineAudioCtx = new OfflineAudioContext(1, duration*48000, 48000);
        const originTrackSource = offlineAudioCtx.createBufferSource();
        originTrackSource.buffer = trackSource.buffer;
        originTrackSource.connect(offlineAudioCtx.destination);

        const recordedArrayBuffer = await recordedChunksBlob.arrayBuffer();
        const recordedAudioBuffer = await audioCtx.decodeAudioData(recordedArrayBuffer);
        const recordedTrackSource = offlineAudioCtx.createBufferSource();
        recordedTrackSource.buffer = recordedAudioBuffer;
        const gain = offlineAudioCtx.createGain();
        gain.gain.value = (trackAvg - avg)/255*(maxDecibels- minDecibels);
        recordedTrackSource.connect(gain);
        gain.connect(offlineAudioCtx.destination);

        originTrackSource.start();
        recordedTrackSource.start();
        const render = await offlineAudioCtx.startRendering();
        const mixRawData = render.getChannelData(0);
        const mixDataBlob = new Blob(mixRawData);
        var mix = audioCtx.createBufferSource();
        mix.buffer = render;
        mix.connect(audioCtx.destination);
        mix.start();
      });

      mediaRecorder.start();
      trackSource.start();

    };

    navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleMicrophoneSuccess);
  </script>
</body>
</html>